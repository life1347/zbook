// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: comment_relation.sql

package db

import (
	"context"
	"time"
)

const createCommentRelation = `-- name: CreateCommentRelation :exec
INSERT INTO comment_relations (
  user_id,
  comment_id,
  relation_type
) VALUES ($1,$2,$3)
`

type CreateCommentRelationParams struct {
	UserID       int64  `json:"user_id"`
	CommentID    int64  `json:"comment_id"`
	RelationType string `json:"relation_type"`
}

func (q *Queries) CreateCommentRelation(ctx context.Context, arg CreateCommentRelationParams) error {
	_, err := q.db.Exec(ctx, createCommentRelation, arg.UserID, arg.CommentID, arg.RelationType)
	return err
}

const createCommentReport = `-- name: CreateCommentReport :exec
INSERT INTO comment_reports (
  user_id,
  comment_id,
  report_content
) VALUES ($1,$2,$3)
`

type CreateCommentReportParams struct {
	UserID        int64  `json:"user_id"`
	CommentID     int64  `json:"comment_id"`
	ReportContent string `json:"report_content"`
}

func (q *Queries) CreateCommentReport(ctx context.Context, arg CreateCommentReportParams) error {
	_, err := q.db.Exec(ctx, createCommentReport, arg.UserID, arg.CommentID, arg.ReportContent)
	return err
}

const deleteCommentRelation = `-- name: DeleteCommentRelation :exec
DELETE FROM comment_relations
WHERE user_id=$1 and comment_id=$2 and relation_type=$3
`

type DeleteCommentRelationParams struct {
	UserID       int64  `json:"user_id"`
	CommentID    int64  `json:"comment_id"`
	RelationType string `json:"relation_type"`
}

func (q *Queries) DeleteCommentRelation(ctx context.Context, arg DeleteCommentRelationParams) error {
	_, err := q.db.Exec(ctx, deleteCommentRelation, arg.UserID, arg.CommentID, arg.RelationType)
	return err
}

const getListCommentReportCount = `-- name: GetListCommentReportCount :one
SELECT 
  COUNT(*)
FROM comment_reports
JOIN users ON users.user_id = comment_reports.user_id
JOIN comments ON comments.comment_id = comment_reports.comment_id
JOIN markdowns ON comments.markdown_id = markdowns.markdown_id
JOIN repos ON repos.repo_id = markdowns.repo_id
JOIN users ura ON ura.user_id = repos.user_id
JOIN users as uc ON comments.user_id = uc.user_id
`

func (q *Queries) GetListCommentReportCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getListCommentReportCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueryCommentReportCount = `-- name: GetQueryCommentReportCount :one
SELECT 
  COUNT(*)
FROM comment_reports
JOIN users as ur ON ur.user_id = comment_reports.user_id
JOIN comments ON comments.comment_id = comment_reports.comment_id
JOIN markdowns ON comments.markdown_id = markdowns.markdown_id
JOIN repos ON repos.repo_id = markdowns.repo_id
JOIN users as uc ON comments.user_id = uc.user_id
WHERE (
  comments.fts_comment_zh @@ plainto_tsquery($1)
  OR comments.fts_comment_en @@ plainto_tsquery($1)
  OR comment_reports.fts_report_zh @@ plainto_tsquery($1) 
  OR comment_reports.fts_report_en @@ plainto_tsquery($1) 
  OR uc.fts_username @@ plainto_tsquery($1)  
  OR ur.fts_username @@ plainto_tsquery($1)  
  )
`

func (q *Queries) GetQueryCommentReportCount(ctx context.Context, query string) (int64, error) {
	row := q.db.QueryRow(ctx, getQueryCommentReportCount, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listCommentReport = `-- name: ListCommentReport :many
SELECT 
  comment_reports.report_id, comment_reports.user_id, comment_reports.comment_id, comment_reports.report_content, comment_reports.processed, comment_reports.created_at, comment_reports.fts_report_zh, comment_reports.fts_report_en,users.username,comments.comment_content,
  repos.repo_name,ura.username as repo_username,markdowns.relative_path
FROM comment_reports
JOIN users ON users.user_id = comment_reports.user_id
JOIN comments ON comments.comment_id = comment_reports.comment_id
JOIN markdowns ON comments.markdown_id = markdowns.markdown_id
JOIN repos ON repos.repo_id = markdowns.repo_id
JOIN users as ura ON ura.user_id = repos.user_id
JOIN users as uc ON comments.user_id = uc.user_id
ORDER BY comment_reports.created_at Desc
LIMIT $1
OFFSET $2
`

type ListCommentReportParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCommentReportRow struct {
	ReportID       int64     `json:"report_id"`
	UserID         int64     `json:"user_id"`
	CommentID      int64     `json:"comment_id"`
	ReportContent  string    `json:"report_content"`
	Processed      bool      `json:"processed"`
	CreatedAt      time.Time `json:"created_at"`
	FtsReportZh    string    `json:"fts_report_zh"`
	FtsReportEn    string    `json:"fts_report_en"`
	Username       string    `json:"username"`
	CommentContent string    `json:"comment_content"`
	RepoName       string    `json:"repo_name"`
	RepoUsername   string    `json:"repo_username"`
	RelativePath   string    `json:"relative_path"`
}

func (q *Queries) ListCommentReport(ctx context.Context, arg ListCommentReportParams) ([]ListCommentReportRow, error) {
	rows, err := q.db.Query(ctx, listCommentReport, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommentReportRow{}
	for rows.Next() {
		var i ListCommentReportRow
		if err := rows.Scan(
			&i.ReportID,
			&i.UserID,
			&i.CommentID,
			&i.ReportContent,
			&i.Processed,
			&i.CreatedAt,
			&i.FtsReportZh,
			&i.FtsReportEn,
			&i.Username,
			&i.CommentContent,
			&i.RepoName,
			&i.RepoUsername,
			&i.RelativePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryCommentReport = `-- name: QueryCommentReport :many
SELECT 
  comment_reports.report_id, comment_reports.user_id, comment_reports.comment_id, comment_reports.report_content, comment_reports.processed, comment_reports.created_at, comment_reports.fts_report_zh, comment_reports.fts_report_en,ur.username,comments.comment_content,
    repos.repo_name,ura.username as repo_username,markdowns.relative_path,
      ROUND(ts_rank(comments.fts_comment_zh, plainto_tsquery($3))) 
    + ROUND(ts_rank(comments.fts_comment_en, plainto_tsquery($3))) 
    + ROUND(ts_rank(comment_reports.fts_report_zh, plainto_tsquery($3)))
    + ROUND(ts_rank(comment_reports.fts_report_en, plainto_tsquery($3)))
    + ROUND(ts_rank(ur.fts_username, plainto_tsquery($3))) 
    + ROUND(ts_rank(uc.fts_username, plainto_tsquery($3))) 
    + ROUND(ts_rank(repos.fts_repo_en, plainto_tsquery($3))) 
    + ROUND(ts_rank(repos.fts_repo_zh, plainto_tsquery($3))) 
     as rank
FROM comment_reports
JOIN users as ur ON ur.user_id = comment_reports.user_id
JOIN comments ON comments.comment_id = comment_reports.comment_id
JOIN markdowns ON comments.markdown_id = markdowns.markdown_id
JOIN repos ON repos.repo_id = markdowns.repo_id
JOIN users as ura ON ura.user_id = repos.user_id
JOIN users as uc ON comments.user_id = uc.user_id
WHERE (
  comments.fts_comment_zh @@ plainto_tsquery($3)
  OR comments.fts_comment_en @@ plainto_tsquery($3)
  OR comment_reports.fts_report_zh @@ plainto_tsquery($3) 
  OR comment_reports.fts_report_en @@ plainto_tsquery($3) 
  OR uc.fts_username @@ plainto_tsquery($3)  
  OR ur.fts_username @@ plainto_tsquery($3)  
  OR repos.fts_repo_en @@ plainto_tsquery($3)  
  OR repos.fts_repo_zh @@ plainto_tsquery($3)  
  )
ORDER BY rank Desc
LIMIT $1
OFFSET $2
`

type QueryCommentReportParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Query  string `json:"query"`
}

type QueryCommentReportRow struct {
	ReportID       int64     `json:"report_id"`
	UserID         int64     `json:"user_id"`
	CommentID      int64     `json:"comment_id"`
	ReportContent  string    `json:"report_content"`
	Processed      bool      `json:"processed"`
	CreatedAt      time.Time `json:"created_at"`
	FtsReportZh    string    `json:"fts_report_zh"`
	FtsReportEn    string    `json:"fts_report_en"`
	Username       string    `json:"username"`
	CommentContent string    `json:"comment_content"`
	RepoName       string    `json:"repo_name"`
	RepoUsername   string    `json:"repo_username"`
	RelativePath   string    `json:"relative_path"`
	Rank           int32     `json:"rank"`
}

func (q *Queries) QueryCommentReport(ctx context.Context, arg QueryCommentReportParams) ([]QueryCommentReportRow, error) {
	rows, err := q.db.Query(ctx, queryCommentReport, arg.Limit, arg.Offset, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryCommentReportRow{}
	for rows.Next() {
		var i QueryCommentReportRow
		if err := rows.Scan(
			&i.ReportID,
			&i.UserID,
			&i.CommentID,
			&i.ReportContent,
			&i.Processed,
			&i.CreatedAt,
			&i.FtsReportZh,
			&i.FtsReportEn,
			&i.Username,
			&i.CommentContent,
			&i.RepoName,
			&i.RepoUsername,
			&i.RelativePath,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommentReportStatus = `-- name: UpdateCommentReportStatus :exec
UPDATE comment_reports
SET processed=$2
WHERE report_id = $1
`

type UpdateCommentReportStatusParams struct {
	ReportID  int64 `json:"report_id"`
	Processed bool  `json:"processed"`
}

func (q *Queries) UpdateCommentReportStatus(ctx context.Context, arg UpdateCommentReportStatusParams) error {
	_, err := q.db.Exec(ctx, updateCommentReportStatus, arg.ReportID, arg.Processed)
	return err
}
