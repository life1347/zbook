// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: follow.sql

package db

import (
	"context"
	"time"
)

const createFollow = `-- name: CreateFollow :one
INSERT INTO follows (
  follower_id,
  following_id
) VALUES ($1, $2) 
RETURNING follow_id, follower_id, following_id, created_at
`

type CreateFollowParams struct {
	FollowerID  int64 `json:"follower_id"`
	FollowingID int64 `json:"following_id"`
}

func (q *Queries) CreateFollow(ctx context.Context, arg CreateFollowParams) (Follow, error) {
	row := q.db.QueryRow(ctx, createFollow, arg.FollowerID, arg.FollowingID)
	var i Follow
	err := row.Scan(
		&i.FollowID,
		&i.FollowerID,
		&i.FollowingID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteFollow = `-- name: DeleteFollow :one
DELETE FROM follows
WHERE follower_id= $1 and following_id=$2
RETURNING follow_id
`

type DeleteFollowParams struct {
	FollowerID  int64 `json:"follower_id"`
	FollowingID int64 `json:"following_id"`
}

func (q *Queries) DeleteFollow(ctx context.Context, arg DeleteFollowParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteFollow, arg.FollowerID, arg.FollowingID)
	var follow_id int64
	err := row.Scan(&follow_id)
	return follow_id, err
}

const getListFollowerCount = `-- name: GetListFollowerCount :one
SELECT 
    COUNT(*)
FROM 
    users u
JOIN 
    follows f ON f.follower_id = u.user_id
LEFT JOIN 
    follows ff ON ff.follower_id = $1 AND ff.following_id = u.user_id
LEFT JOIN repos r ON r.user_id = u.user_id AND (
        r.visibility_level = 'public' OR 
        r.visibility_level = 'signed' OR
        (r.visibility_level = 'chosen' AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $1 AND repo_relations.relation_type = 'visi')) OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND (r.user_id = $1 OR $2::text='admin')))
WHERE 
    f.following_id = $3 AND (u.blocked='false' OR $2::text='admin')
`

type GetListFollowerCountParams struct {
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	UserID    int64  `json:"user_id"`
}

func (q *Queries) GetListFollowerCount(ctx context.Context, arg GetListFollowerCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getListFollowerCount, arg.CurUserID, arg.Role, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getListFollowingCount = `-- name: GetListFollowingCount :one
SELECT 
    COUNT(*)
FROM 
    users u
JOIN 
    follows f ON f.following_id = u.user_id
LEFT JOIN 
    follows ff ON ff.follower_id = $1 AND ff.following_id = u.user_id
LEFT JOIN repos r ON r.user_id = u.user_id AND (
        r.visibility_level = 'public' OR 
        r.visibility_level = 'signed' OR
        (r.visibility_level = 'chosen' AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $1 AND repo_relations.relation_type = 'visi')) OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND (r.user_id = $1 OR $2::text='admin')))
WHERE 
    f.follower_id = $3 AND (u.blocked='false' OR $2::text='admin')
`

type GetListFollowingCountParams struct {
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	UserID    int64  `json:"user_id"`
}

func (q *Queries) GetListFollowingCount(ctx context.Context, arg GetListFollowingCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getListFollowingCount, arg.CurUserID, arg.Role, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueryFollowerCount = `-- name: GetQueryFollowerCount :one
SELECT 
    COUNT(*)
FROM 
    users u
JOIN 
    follows f ON f.follower_id = u.user_id
LEFT JOIN 
    follows ff ON ff.follower_id = $1 AND ff.following_id = u.user_id
LEFT JOIN repos r ON r.user_id = u.user_id AND (
        r.visibility_level = 'public' OR 
        r.visibility_level = 'signed' OR
        (r.visibility_level = 'chosen' AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $1 AND repo_relations.relation_type = 'visi')) OR
       ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND (r.user_id = $1 OR $2::text='admin')))
WHERE 
    f.following_id = $3 and u.fts_username @@ plainto_tsquery($4) AND (u.blocked='false' OR $2::text='admin')
`

type GetQueryFollowerCountParams struct {
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	UserID    int64  `json:"user_id"`
	Query     string `json:"query"`
}

func (q *Queries) GetQueryFollowerCount(ctx context.Context, arg GetQueryFollowerCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getQueryFollowerCount,
		arg.CurUserID,
		arg.Role,
		arg.UserID,
		arg.Query,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueryFollowingCount = `-- name: GetQueryFollowingCount :one
SELECT 
    COUNT(*)
FROM 
    users u
JOIN 
    follows f ON f.following_id = u.user_id
LEFT JOIN 
    follows ff ON ff.follower_id = $1 AND ff.following_id = u.user_id
LEFT JOIN repos r ON r.user_id = u.user_id AND (
        r.visibility_level = 'public' OR 
        r.visibility_level = 'signed' OR
        (r.visibility_level = 'chosen' AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $1 AND repo_relations.relation_type = 'visi')) OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND (r.user_id = $1 OR $2::text='admin')))
WHERE 
    f.follower_id = $3 and u.fts_username @@ plainto_tsquery($4) AND (u.blocked='false' OR $2::text='admin')
`

type GetQueryFollowingCountParams struct {
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	UserID    int64  `json:"user_id"`
	Query     string `json:"query"`
}

func (q *Queries) GetQueryFollowingCount(ctx context.Context, arg GetQueryFollowingCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getQueryFollowingCount,
		arg.CurUserID,
		arg.Role,
		arg.UserID,
		arg.Query,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isFollowing = `-- name: IsFollowing :one
SELECT EXISTS (
  SELECT 1
  FROM follows
  WHERE follower_id = $1
    AND following_id = $2
  LIMIT 1
)
`

type IsFollowingParams struct {
	FollowerID  int64 `json:"follower_id"`
	FollowingID int64 `json:"following_id"`
}

func (q *Queries) IsFollowing(ctx context.Context, arg IsFollowingParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFollowing, arg.FollowerID, arg.FollowingID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listFollower = `-- name: ListFollower :many
SELECT 
    u.user_id, u.username, u.email, u.hashed_password, u.blocked, u.verified, u.motto, u.user_role, u.onboarding, u.created_at, u.updated_at, u.unread_count, u.unread_count_updated_at, u.fts_username,
    CASE WHEN MAX(ff.follower_id) IS NOT NULL THEN true ELSE false END AS is_following,
    COUNT(DISTINCT r.repo_id) as repo_count
FROM 
    users u
JOIN 
    follows f ON f.follower_id = u.user_id
LEFT JOIN 
    follows ff ON ff.follower_id = $3 AND ff.following_id = u.user_id
LEFT JOIN repos r ON r.user_id = u.user_id AND (
        r.visibility_level = 'public' OR 
        r.visibility_level = 'signed' OR
        (r.visibility_level = 'chosen' AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $3 AND repo_relations.relation_type = 'visi')) OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND (r.user_id = $3 OR $4::text='admin')))
WHERE 
    f.following_id = $5 AND (u.blocked='false' OR $4::text='admin')
GROUP BY 
    u.user_id,f.created_at
ORDER BY 
    f.created_at DESC
LIMIT $1
OFFSET $2
`

type ListFollowerParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	UserID    int64  `json:"user_id"`
}

type ListFollowerRow struct {
	UserID               int64     `json:"user_id"`
	Username             string    `json:"username"`
	Email                string    `json:"email"`
	HashedPassword       string    `json:"hashed_password"`
	Blocked              bool      `json:"blocked"`
	Verified             bool      `json:"verified"`
	Motto                string    `json:"motto"`
	UserRole             string    `json:"user_role"`
	Onboarding           bool      `json:"onboarding"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	UnreadCount          int32     `json:"unread_count"`
	UnreadCountUpdatedAt time.Time `json:"unread_count_updated_at"`
	FtsUsername          string    `json:"fts_username"`
	IsFollowing          bool      `json:"is_following"`
	RepoCount            int64     `json:"repo_count"`
}

func (q *Queries) ListFollower(ctx context.Context, arg ListFollowerParams) ([]ListFollowerRow, error) {
	rows, err := q.db.Query(ctx, listFollower,
		arg.Limit,
		arg.Offset,
		arg.CurUserID,
		arg.Role,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFollowerRow{}
	for rows.Next() {
		var i ListFollowerRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.Blocked,
			&i.Verified,
			&i.Motto,
			&i.UserRole,
			&i.Onboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnreadCount,
			&i.UnreadCountUpdatedAt,
			&i.FtsUsername,
			&i.IsFollowing,
			&i.RepoCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFollowing = `-- name: ListFollowing :many
SELECT 
    u.user_id, u.username, u.email, u.hashed_password, u.blocked, u.verified, u.motto, u.user_role, u.onboarding, u.created_at, u.updated_at, u.unread_count, u.unread_count_updated_at, u.fts_username,
    CASE WHEN MAX(ff.follower_id) IS NOT NULL THEN true ELSE false END AS is_following,
    COUNT(DISTINCT r.repo_id) as repo_count
FROM 
    users u
JOIN 
    follows f ON f.following_id = u.user_id
LEFT JOIN 
    follows ff ON ff.follower_id = $3 AND ff.following_id = u.user_id
LEFT JOIN repos r ON r.user_id = u.user_id AND (
        r.visibility_level = 'public' OR 
        r.visibility_level = 'signed' OR
        (r.visibility_level = 'chosen' AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $3 AND repo_relations.relation_type = 'visi')) OR
       ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND (r.user_id = $3 OR $4::text='admin')))
WHERE 
    f.follower_id = $5 AND (u.blocked='false' OR $4::text='admin')
GROUP BY 
    u.user_id,f.created_at
ORDER BY 
    f.created_at DESC
LIMIT $1
OFFSET $2
`

type ListFollowingParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	UserID    int64  `json:"user_id"`
}

type ListFollowingRow struct {
	UserID               int64     `json:"user_id"`
	Username             string    `json:"username"`
	Email                string    `json:"email"`
	HashedPassword       string    `json:"hashed_password"`
	Blocked              bool      `json:"blocked"`
	Verified             bool      `json:"verified"`
	Motto                string    `json:"motto"`
	UserRole             string    `json:"user_role"`
	Onboarding           bool      `json:"onboarding"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	UnreadCount          int32     `json:"unread_count"`
	UnreadCountUpdatedAt time.Time `json:"unread_count_updated_at"`
	FtsUsername          string    `json:"fts_username"`
	IsFollowing          bool      `json:"is_following"`
	RepoCount            int64     `json:"repo_count"`
}

func (q *Queries) ListFollowing(ctx context.Context, arg ListFollowingParams) ([]ListFollowingRow, error) {
	rows, err := q.db.Query(ctx, listFollowing,
		arg.Limit,
		arg.Offset,
		arg.CurUserID,
		arg.Role,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFollowingRow{}
	for rows.Next() {
		var i ListFollowingRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.Blocked,
			&i.Verified,
			&i.Motto,
			&i.UserRole,
			&i.Onboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnreadCount,
			&i.UnreadCountUpdatedAt,
			&i.FtsUsername,
			&i.IsFollowing,
			&i.RepoCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryFollower = `-- name: QueryFollower :many
SELECT 
    u.user_id, u.username, u.email, u.hashed_password, u.blocked, u.verified, u.motto, u.user_role, u.onboarding, u.created_at, u.updated_at, u.unread_count, u.unread_count_updated_at, u.fts_username,
    ts_rank(u.fts_username, plainto_tsquery($3)) as rank,
    CASE WHEN MAX(ff.follower_id) IS NOT NULL THEN true ELSE false END AS is_following,
    COUNT(DISTINCT r.repo_id) as repo_count
FROM 
    users u
JOIN 
    follows f ON f.follower_id = u.user_id
LEFT JOIN 
    follows ff ON ff.follower_id = $4 AND ff.following_id = u.user_id
LEFT JOIN repos r ON r.user_id = u.user_id AND (
        r.visibility_level = 'public' OR 
        r.visibility_level = 'signed' OR
        (r.visibility_level = 'chosen' AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $4 AND repo_relations.relation_type = 'visi')) OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND (r.user_id = $4 OR $5::text='admin')))
WHERE 
    f.following_id = $6 and u.fts_username @@ plainto_tsquery($3) AND (u.blocked='false' OR $5::text='admin')
GROUP BY 
    u.user_id
ORDER BY 
    rank DESC
LIMIT $1
OFFSET $2
`

type QueryFollowerParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Query     string `json:"query"`
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	UserID    int64  `json:"user_id"`
}

type QueryFollowerRow struct {
	UserID               int64     `json:"user_id"`
	Username             string    `json:"username"`
	Email                string    `json:"email"`
	HashedPassword       string    `json:"hashed_password"`
	Blocked              bool      `json:"blocked"`
	Verified             bool      `json:"verified"`
	Motto                string    `json:"motto"`
	UserRole             string    `json:"user_role"`
	Onboarding           bool      `json:"onboarding"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	UnreadCount          int32     `json:"unread_count"`
	UnreadCountUpdatedAt time.Time `json:"unread_count_updated_at"`
	FtsUsername          string    `json:"fts_username"`
	Rank                 float32   `json:"rank"`
	IsFollowing          bool      `json:"is_following"`
	RepoCount            int64     `json:"repo_count"`
}

func (q *Queries) QueryFollower(ctx context.Context, arg QueryFollowerParams) ([]QueryFollowerRow, error) {
	rows, err := q.db.Query(ctx, queryFollower,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.CurUserID,
		arg.Role,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryFollowerRow{}
	for rows.Next() {
		var i QueryFollowerRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.Blocked,
			&i.Verified,
			&i.Motto,
			&i.UserRole,
			&i.Onboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnreadCount,
			&i.UnreadCountUpdatedAt,
			&i.FtsUsername,
			&i.Rank,
			&i.IsFollowing,
			&i.RepoCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryFollowing = `-- name: QueryFollowing :many
SELECT 
    u.user_id, u.username, u.email, u.hashed_password, u.blocked, u.verified, u.motto, u.user_role, u.onboarding, u.created_at, u.updated_at, u.unread_count, u.unread_count_updated_at, u.fts_username,
    ts_rank(u.fts_username, plainto_tsquery($3)) as rank,
    CASE WHEN MAX(ff.follower_id) IS NOT NULL THEN true ELSE false END AS is_following,
    COUNT(DISTINCT r.repo_id) as repo_count
FROM 
    users u
JOIN 
    follows f ON f.following_id = u.user_id
LEFT JOIN 
    follows ff ON ff.follower_id = $4 AND ff.following_id = u.user_id
LEFT JOIN repos r ON r.user_id = u.user_id AND (
        r.visibility_level = 'public' OR 
        r.visibility_level = 'signed' OR
        (r.visibility_level = 'chosen' AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $4 AND repo_relations.relation_type = 'visi')) OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND (r.user_id = $4 OR $5::text='admin')))
WHERE 
    f.follower_id = $6 and u.fts_username @@ plainto_tsquery($3) AND (u.blocked='false' OR $5::text='admin')
GROUP BY 
    u.user_id
ORDER BY 
    rank DESC
LIMIT $1
OFFSET $2
`

type QueryFollowingParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Query     string `json:"query"`
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	UserID    int64  `json:"user_id"`
}

type QueryFollowingRow struct {
	UserID               int64     `json:"user_id"`
	Username             string    `json:"username"`
	Email                string    `json:"email"`
	HashedPassword       string    `json:"hashed_password"`
	Blocked              bool      `json:"blocked"`
	Verified             bool      `json:"verified"`
	Motto                string    `json:"motto"`
	UserRole             string    `json:"user_role"`
	Onboarding           bool      `json:"onboarding"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	UnreadCount          int32     `json:"unread_count"`
	UnreadCountUpdatedAt time.Time `json:"unread_count_updated_at"`
	FtsUsername          string    `json:"fts_username"`
	Rank                 float32   `json:"rank"`
	IsFollowing          bool      `json:"is_following"`
	RepoCount            int64     `json:"repo_count"`
}

func (q *Queries) QueryFollowing(ctx context.Context, arg QueryFollowingParams) ([]QueryFollowingRow, error) {
	rows, err := q.db.Query(ctx, queryFollowing,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.CurUserID,
		arg.Role,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryFollowingRow{}
	for rows.Next() {
		var i QueryFollowingRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.Blocked,
			&i.Verified,
			&i.Motto,
			&i.UserRole,
			&i.Onboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnreadCount,
			&i.UnreadCountUpdatedAt,
			&i.FtsUsername,
			&i.Rank,
			&i.IsFollowing,
			&i.RepoCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
