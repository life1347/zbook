// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user_update.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  username,
  email,
  hashed_password
) VALUES (
  $1, $2, $3
) RETURNING user_id, username, email, hashed_password, blocked, verified, motto, user_role, onboarding, created_at, updated_at, unread_count, unread_count_updated_at, fts_username
`

type CreateUserParams struct {
	Username       string `json:"username"`
	Email          string `json:"email"`
	HashedPassword string `json:"hashed_password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Email, arg.HashedPassword)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.Blocked,
		&i.Verified,
		&i.Motto,
		&i.UserRole,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnreadCount,
		&i.UnreadCountUpdatedAt,
		&i.FtsUsername,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE username = $1
`

func (q *Queries) DeleteUser(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, deleteUser, username)
	return err
}

const resetUnreadCount = `-- name: ResetUnreadCount :exec
UPDATE users
SET unread_count_updated_at = now(),
  unread_count = (
  SELECT COUNT(*) FROM (
    SELECT noti_id FROM follower_notifications
    WHERE user_id = users.user_id AND created_at  > now() AND readed = false 
    UNION ALL
    SELECT noti_id FROM comment_notifications
    WHERE user_id = users.user_id AND created_at  > now() AND readed = false 
    UNION ALL
    SELECT noti_id FROM system_notifications
    WHERE user_id = users.user_id AND created_at  > now() AND readed = false 
    UNION ALL
    SELECT noti_id FROM repo_notifications
    WHERE user_id = users.user_id AND created_at  > now() AND readed = false 
  ) AS subquery
) 
WHERE users.username = $1
`

func (q *Queries) ResetUnreadCount(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, resetUnreadCount, username)
	return err
}

const updateUnreadCount = `-- name: UpdateUnreadCount :exec
UPDATE users
SET unread_count = (
  SELECT COUNT(*) FROM (
    SELECT noti_id FROM follower_notifications
    WHERE user_id = users.user_id AND created_at  > users.unread_count_updated_at AND readed = false 
    UNION ALL
    SELECT noti_id FROM comment_notifications
    WHERE user_id = users.user_id AND created_at  > users.unread_count_updated_at AND readed = false 
    UNION ALL
    SELECT noti_id FROM system_notifications
    WHERE user_id = users.user_id AND created_at  > users.unread_count_updated_at AND readed = false 
    UNION ALL
    SELECT noti_id FROM repo_notifications
    WHERE user_id = users.user_id AND created_at  > users.unread_count_updated_at AND readed = false 
  ) AS subquery
) 
WHERE users.user_id = $1
`

func (q *Queries) UpdateUnreadCount(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, updateUnreadCount, userID)
	return err
}

const updateUserBasicInfo = `-- name: UpdateUserBasicInfo :one
UPDATE users
SET motto=COALESCE($1,motto),
hashed_password=COALESCE($2,hashed_password),
user_role=COALESCE($3,user_role),
onboarding=COALESCE($4,onboarding),
blocked=COALESCE($5,blocked),
verified=COALESCE($6,verified)
WHERE username = $7
RETURNING user_id, username, email, hashed_password, blocked, verified, motto, user_role, onboarding, created_at, updated_at, unread_count, unread_count_updated_at, fts_username
`

type UpdateUserBasicInfoParams struct {
	Motto          pgtype.Text `json:"motto"`
	HashedPassword pgtype.Text `json:"hashed_password"`
	UserRole       pgtype.Text `json:"user_role"`
	Onboarding     pgtype.Bool `json:"onboarding"`
	Blocked        pgtype.Bool `json:"blocked"`
	Verified       pgtype.Bool `json:"verified"`
	Username       string      `json:"username"`
}

func (q *Queries) UpdateUserBasicInfo(ctx context.Context, arg UpdateUserBasicInfoParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserBasicInfo,
		arg.Motto,
		arg.HashedPassword,
		arg.UserRole,
		arg.Onboarding,
		arg.Blocked,
		arg.Verified,
		arg.Username,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.Blocked,
		&i.Verified,
		&i.Motto,
		&i.UserRole,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnreadCount,
		&i.UnreadCountUpdatedAt,
		&i.FtsUsername,
	)
	return i, err
}
