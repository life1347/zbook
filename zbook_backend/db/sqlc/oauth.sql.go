// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: oauth.sql

package db

import (
	"context"
	"time"
)

const checkOAuthStatus = `-- name: CheckOAuthStatus :one
SELECT
  COALESCE(COUNT(CASE WHEN "oauth_type" = 'github' THEN 1 END), 0) > 0 AS github_status,
  COALESCE(COUNT(CASE WHEN "oauth_type" = 'google' THEN 1 END), 0) > 0 AS google_status
FROM
  "oauths"
WHERE
  "user_id" = $1
`

type CheckOAuthStatusRow struct {
	GithubStatus bool `json:"github_status"`
	GoogleStatus bool `json:"google_status"`
}

func (q *Queries) CheckOAuthStatus(ctx context.Context, userID int64) (CheckOAuthStatusRow, error) {
	row := q.db.QueryRow(ctx, checkOAuthStatus, userID)
	var i CheckOAuthStatusRow
	err := row.Scan(&i.GithubStatus, &i.GoogleStatus)
	return i, err
}

const createOAuth = `-- name: CreateOAuth :one
INSERT INTO oauths (
  user_id,
  oauth_type,
  app_id
) VALUES (
  $1, $2, $3
) RETURNING oauth_id, user_id, oauth_type, app_id, created_at
`

type CreateOAuthParams struct {
	UserID    int64  `json:"user_id"`
	OauthType string `json:"oauth_type"`
	AppID     string `json:"app_id"`
}

func (q *Queries) CreateOAuth(ctx context.Context, arg CreateOAuthParams) (Oauth, error) {
	row := q.db.QueryRow(ctx, createOAuth, arg.UserID, arg.OauthType, arg.AppID)
	var i Oauth
	err := row.Scan(
		&i.OauthID,
		&i.UserID,
		&i.OauthType,
		&i.AppID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOAuth = `-- name: DeleteOAuth :one
DELETE FROM oauths
WHERE user_id=$1 and oauth_type=$2
RETURNING oauth_id, user_id, oauth_type, app_id, created_at
`

type DeleteOAuthParams struct {
	UserID    int64  `json:"user_id"`
	OauthType string `json:"oauth_type"`
}

func (q *Queries) DeleteOAuth(ctx context.Context, arg DeleteOAuthParams) (Oauth, error) {
	row := q.db.QueryRow(ctx, deleteOAuth, arg.UserID, arg.OauthType)
	var i Oauth
	err := row.Scan(
		&i.OauthID,
		&i.UserID,
		&i.OauthType,
		&i.AppID,
		&i.CreatedAt,
	)
	return i, err
}

const getOAuthUser = `-- name: GetOAuthUser :one
SELECT oauth_id, oauths.user_id, oauth_type, app_id, oauths.created_at, users.user_id, username, email, hashed_password, blocked, verified, motto, user_role, onboarding, users.created_at, updated_at, unread_count, unread_count_updated_at, fts_username
FROM oauths
JOIN users ON oauths.user_id = users.user_id
WHERE oauth_type = $1 and app_id = $2 LIMIT 1
FOR NO KEY UPDATE
`

type GetOAuthUserParams struct {
	OauthType string `json:"oauth_type"`
	AppID     string `json:"app_id"`
}

type GetOAuthUserRow struct {
	OauthID              int64     `json:"oauth_id"`
	UserID               int64     `json:"user_id"`
	OauthType            string    `json:"oauth_type"`
	AppID                string    `json:"app_id"`
	CreatedAt            time.Time `json:"created_at"`
	UserID_2             int64     `json:"user_id_2"`
	Username             string    `json:"username"`
	Email                string    `json:"email"`
	HashedPassword       string    `json:"hashed_password"`
	Blocked              bool      `json:"blocked"`
	Verified             bool      `json:"verified"`
	Motto                string    `json:"motto"`
	UserRole             string    `json:"user_role"`
	Onboarding           bool      `json:"onboarding"`
	CreatedAt_2          time.Time `json:"created_at_2"`
	UpdatedAt            time.Time `json:"updated_at"`
	UnreadCount          int32     `json:"unread_count"`
	UnreadCountUpdatedAt time.Time `json:"unread_count_updated_at"`
	FtsUsername          string    `json:"fts_username"`
}

func (q *Queries) GetOAuthUser(ctx context.Context, arg GetOAuthUserParams) (GetOAuthUserRow, error) {
	row := q.db.QueryRow(ctx, getOAuthUser, arg.OauthType, arg.AppID)
	var i GetOAuthUserRow
	err := row.Scan(
		&i.OauthID,
		&i.UserID,
		&i.OauthType,
		&i.AppID,
		&i.CreatedAt,
		&i.UserID_2,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.Blocked,
		&i.Verified,
		&i.Motto,
		&i.UserRole,
		&i.Onboarding,
		&i.CreatedAt_2,
		&i.UpdatedAt,
		&i.UnreadCount,
		&i.UnreadCountUpdatedAt,
		&i.FtsUsername,
	)
	return i, err
}
