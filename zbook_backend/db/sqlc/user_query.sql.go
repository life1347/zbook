// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user_query.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDailyCreateUserCount = `-- name: GetDailyCreateUserCount :many
SELECT 
    (created_at AT TIME ZONE $1)::date AS registration_date, 
    COUNT(*) AS new_users_count
FROM users
WHERE 
    (created_at AT TIME ZONE $1) >= (CURRENT_DATE AT TIME ZONE $1) - ($2 || ' days')::INTERVAL
GROUP BY 
    registration_date
ORDER BY 
    registration_date DESC
`

type GetDailyCreateUserCountParams struct {
	Timezone     string      `json:"timezone"`
	IntervalDays pgtype.Text `json:"interval_days"`
}

type GetDailyCreateUserCountRow struct {
	RegistrationDate pgtype.Date `json:"registration_date"`
	NewUsersCount    int64       `json:"new_users_count"`
}

func (q *Queries) GetDailyCreateUserCount(ctx context.Context, arg GetDailyCreateUserCountParams) ([]GetDailyCreateUserCountRow, error) {
	rows, err := q.db.Query(ctx, getDailyCreateUserCount, arg.Timezone, arg.IntervalDays)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyCreateUserCountRow{}
	for rows.Next() {
		var i GetDailyCreateUserCountRow
		if err := rows.Scan(&i.RegistrationDate, &i.NewUsersCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListUserCount = `-- name: GetListUserCount :one
SELECT COUNT(*)
FROM users
WHERE
users.blocked = 'false' OR $1::text='admin'
`

func (q *Queries) GetListUserCount(ctx context.Context, role string) (int64, error) {
	row := q.db.QueryRow(ctx, getListUserCount, role)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueryUserCount = `-- name: GetQueryUserCount :one
select COUNT(*)
from users 
where (users.blocked='false' OR $1::text='admin') AND fts_username @@ plainto_tsquery($2)
`

type GetQueryUserCountParams struct {
	Role  string `json:"role"`
	Query string `json:"query"`
}

func (q *Queries) GetQueryUserCount(ctx context.Context, arg GetQueryUserCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getQueryUserCount, arg.Role, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnReadCount = `-- name: GetUnReadCount :one
SELECT unread_count
FROM users
WHERE username = $1 
LIMIT 1
`

func (q *Queries) GetUnReadCount(ctx context.Context, username string) (int32, error) {
	row := q.db.QueryRow(ctx, getUnReadCount, username)
	var unread_count int32
	err := row.Scan(&unread_count)
	return unread_count, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, username, email, hashed_password, blocked, verified, motto, user_role, onboarding, created_at, updated_at, unread_count, unread_count_updated_at, fts_username
FROM users
WHERE users.email = $1 
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.Blocked,
		&i.Verified,
		&i.Motto,
		&i.UserRole,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnreadCount,
		&i.UnreadCountUpdatedAt,
		&i.FtsUsername,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT user_id, username, email, hashed_password, blocked, verified, motto, user_role, onboarding, created_at, updated_at, unread_count, unread_count_updated_at, fts_username
FROM users
WHERE username = $1 
LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.Blocked,
		&i.Verified,
		&i.Motto,
		&i.UserRole,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnreadCount,
		&i.UnreadCountUpdatedAt,
		&i.FtsUsername,
	)
	return i, err
}

const getUserInfo = `-- name: GetUserInfo :one
WITH liked_repos_count AS (
  SELECT
    Count(*) as like_count
  FROM
      repos r
  JOIN 
      repo_relations AS rr ON r.repo_id = rr.repo_id
  JOIN
      users as ur ON ur.user_id=r.user_id
  JOIN
      users as uq ON uq.user_id=rr.user_id
  WHERE
    uq.user_id = $3 AND rr.relation_type='like' AND ( 
      ($1::text='admin' AND $4::bool ) OR (
        uq.blocked = FALSE AND ur.blocked =FALSE AND 
        (
          (r.visibility_level = 'public' ) 
          OR
          (r.visibility_level = 'signed' AND $4::bool) 
          OR
          (r.visibility_level = 'chosen' AND $4::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $2 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $2 AND $4::bool)
        )
      )
    )
),
 owned_repos_count AS (
  SELECT
    COUNT(*) as repo_count
  FROM
      repos r
  JOIN
      users as u ON u.user_id=r.user_id
  WHERE
      u.user_id = $3 AND (
        ($1::text='admin' AND $4::bool ) OR (
          u.blocked='false' AND (
            r.visibility_level = 'public'
            OR 
            (r.visibility_level = 'signed' AND $4::bool)
            OR
            (r.visibility_level = 'chosen' AND $4::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $2 AND repo_relations.relation_type = 'visi'))
            OR
            ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $2 AND $4::bool)
          )
        )
      )
)
SELECT 
    u.user_id, u.username, u.email, u.hashed_password, u.blocked, u.verified, u.motto, u.user_role, u.onboarding, u.created_at, u.updated_at, u.unread_count, u.unread_count_updated_at, u.fts_username,
    repo_count,
    like_count,
    (SELECT COUNT(*) FROM follows f1 JOIN users as uf ON uf.user_id = f1.follower_id WHERE f1.following_id = u.user_id and (uf.blocked = 'false' OR $1::text='admin')) AS follower_count,
    (SELECT COUNT(*) FROM follows f2 JOIN users as uf ON uf.user_id = f2.following_id WHERE f2.follower_id = u.user_id and (uf.blocked = 'false' OR $1::text='admin')) AS following_count,
    EXISTS(SELECT 1 FROM follows WHERE follows.follower_id = $2 AND follows.following_id = $3) AS is_following
FROM users u
JOIN liked_repos_count lrc ON 1=1
JOIN owned_repos_count ownrc ON 1=1
WHERE u.user_id = $3
`

type GetUserInfoParams struct {
	Role      string `json:"role"`
	CurUserID int64  `json:"cur_user_id"`
	UserID    int64  `json:"user_id"`
	Signed    bool   `json:"signed"`
}

type GetUserInfoRow struct {
	UserID               int64     `json:"user_id"`
	Username             string    `json:"username"`
	Email                string    `json:"email"`
	HashedPassword       string    `json:"hashed_password"`
	Blocked              bool      `json:"blocked"`
	Verified             bool      `json:"verified"`
	Motto                string    `json:"motto"`
	UserRole             string    `json:"user_role"`
	Onboarding           bool      `json:"onboarding"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	UnreadCount          int32     `json:"unread_count"`
	UnreadCountUpdatedAt time.Time `json:"unread_count_updated_at"`
	FtsUsername          string    `json:"fts_username"`
	RepoCount            int64     `json:"repo_count"`
	LikeCount            int64     `json:"like_count"`
	FollowerCount        int64     `json:"follower_count"`
	FollowingCount       int64     `json:"following_count"`
	IsFollowing          bool      `json:"is_following"`
}

func (q *Queries) GetUserInfo(ctx context.Context, arg GetUserInfoParams) (GetUserInfoRow, error) {
	row := q.db.QueryRow(ctx, getUserInfo,
		arg.Role,
		arg.CurUserID,
		arg.UserID,
		arg.Signed,
	)
	var i GetUserInfoRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.Blocked,
		&i.Verified,
		&i.Motto,
		&i.UserRole,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnreadCount,
		&i.UnreadCountUpdatedAt,
		&i.FtsUsername,
		&i.RepoCount,
		&i.LikeCount,
		&i.FollowerCount,
		&i.FollowingCount,
		&i.IsFollowing,
	)
	return i, err
}

const listUser = `-- name: ListUser :many
SELECT user_id, username, email, hashed_password, blocked, verified, motto, user_role, onboarding, created_at, updated_at, unread_count, unread_count_updated_at, fts_username
FROM users u
WHERE u.blocked = 'false' OR $3::text='admin'
ORDER BY u.created_at DESC
LIMIT $1
OFFSET $2
`

type ListUserParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Role   string `json:"role"`
}

func (q *Queries) ListUser(ctx context.Context, arg ListUserParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUser, arg.Limit, arg.Offset, arg.Role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.Blocked,
			&i.Verified,
			&i.Motto,
			&i.UserRole,
			&i.Onboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnreadCount,
			&i.UnreadCountUpdatedAt,
			&i.FtsUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryUser = `-- name: QueryUser :many
select users.user_id, users.username, users.email, users.hashed_password, users.blocked, users.verified, users.motto, users.user_role, users.onboarding, users.created_at, users.updated_at, users.unread_count, users.unread_count_updated_at, users.fts_username,ts_rank(fts_username, plainto_tsquery($3)) as rank
from users 
where (users.blocked='false' OR $4::text='admin') AND fts_username @@ plainto_tsquery($3)
ORDER BY rank DESC
LIMIT $1
OFFSET $2
`

type QueryUserParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Query  string `json:"query"`
	Role   string `json:"role"`
}

type QueryUserRow struct {
	UserID               int64     `json:"user_id"`
	Username             string    `json:"username"`
	Email                string    `json:"email"`
	HashedPassword       string    `json:"hashed_password"`
	Blocked              bool      `json:"blocked"`
	Verified             bool      `json:"verified"`
	Motto                string    `json:"motto"`
	UserRole             string    `json:"user_role"`
	Onboarding           bool      `json:"onboarding"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	UnreadCount          int32     `json:"unread_count"`
	UnreadCountUpdatedAt time.Time `json:"unread_count_updated_at"`
	FtsUsername          string    `json:"fts_username"`
	Rank                 float32   `json:"rank"`
}

func (q *Queries) QueryUser(ctx context.Context, arg QueryUserParams) ([]QueryUserRow, error) {
	rows, err := q.db.Query(ctx, queryUser,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.Role,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryUserRow{}
	for rows.Next() {
		var i QueryUserRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.Blocked,
			&i.Verified,
			&i.Motto,
			&i.UserRole,
			&i.Onboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnreadCount,
			&i.UnreadCountUpdatedAt,
			&i.FtsUsername,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
